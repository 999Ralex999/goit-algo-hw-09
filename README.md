# Домашнє завдання 9: Жадібні алгоритми та динамічне програмування

## Опис завдання

Реалізовано дві функції для системи видачі решти:

- **find_coins_greedy(amount)** — використовує жадібний алгоритм: завжди вибирає найбільший доступний номінал монети.
- **find_min_coins(amount)** — використовує метод динамічного програмування для знаходження мінімальної кількості монет.

Обидві функції повертають словник із кількістю монет кожного номіналу для заданої суми.

Також додано тести для порівняння часу виконання обох алгоритмів на сумах:
- 113
- 1013
- 1 000 033

## Порівняння ефективності

| Сума | find_coins_greedy (час) | find_min_coins (час) |
|:---|:---|:---|
| 113 | дуже швидко (O(k)) | трохи довше (O(n * k)) |
| 1013 | швидко | відчутно повільніше |
| 1 000 033 | швидко | значно повільніше |

- **Жадібний алгоритм** має складність **O(k)** (де k — кількість номіналів монет), що робить його надзвичайно швидким навіть для дуже великих сум.
- **Алгоритм динамічного програмування** має складність **O(n * k)**, що робить його менш ефективним для великих сум, але він гарантує мінімальну кількість монет.

## Висновок

- Якщо важлива **швидкість** — краще використовувати **жадібний алгоритм**.
- Якщо важливо отримати **мінімальну кількість монет** (особливо при нестандартних наборах монет) — слід використовувати **динамічне програмування**.
- У реальних касових апаратах при стандартних наборах монет зазвичай вистачає жадібного алгоритму.

